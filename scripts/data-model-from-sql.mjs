// scripts/data-model-from-sql.mjs
import { readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";

const sql = readFileSync(join(process.cwd(), "db/SCHEMA.sql"), "utf8").replace(/\r\n/g, "\n");
const outPath = join(process.cwd(), "assistant/data-model.md");

const lines = sql.split("\n");

// --- Parse tables -----------------------------------------------------------
const tables = []; // {name, cols:[{name,type,nullable,def}], uniques:[], idx:[]}
for (let i = 0; i < lines.length; i++) {
  const m = lines[i].match(/^\s*create\s+table\s+public\.([a-zA-Z0-9_]+)\s*\(\s*$/i);
  if (!m) continue;
  const name = m[1];
  const cols = [];
  const uniques = [];
  let j = i + 1;
  for (; j < lines.length; j++) {
    const raw = lines[j].trim();
    if (/^\)\s*(tablespace|;)/i.test(raw) || raw === ");") break;
    if (!raw) continue;

    if (/^constraint\s+/i.test(raw)) {
      if (/unique/i.test(raw)) uniques.push(raw.replace(/,\s*$/, ""));
      continue;
    }

    const line = raw.replace(/,\s*$/, "");
    const m2 = line.match(/^"?(?<col>[a-zA-Z0-9_]+)"?\s+(?<type>[^,\s]+(?:\s+\([^)]+\))?(?:\s+with\s+time\s+zone)?)(?<rest>.*)$/i);
    if (!m2) continue;
    const { col, type, rest } = m2.groups;
    const nullable = !/\bnot null\b/i.test(rest || "");
    const defm = (rest || "").match(/\bdefault\s+([^,]+)$/i);
    cols.push({ name: col, type: (type || "").replace(/\s+/g, " ").trim(), nullable, def: defm ? defm[1].trim() : null });
  }
  tables.push({ name, cols, uniques, idx: [] });
  i = j;
}

// --- Parse indexes ----------------------------------------------------------
function tableByName(n) { return tables.find(t => t.name === n); }

for (const L of lines) {
  let m =
    L.match(/^\s*create\s+unique\s+index\s+.*\s+on\s+public\.([a-zA-Z0-9_]+)\s*\((.+)\)/i) ||
    L.match(/^\s*create\s+index\s+.*\s+on\s+public\.([a-zA-Z0-9_]+)\s+using\s+([a-zA-Z0-9_]+)\s*\((.+)\)/i) ||
    L.match(/^\s*create\s+index\s+.*\s+on\s+public\.([a-zA-Z0-9_]+)\s*\((.+)\)/i);
  if (!m) continue;
  const t = tableByName(m[1]);
  if (!t) continue;
  const spec = (m[3] || m[2] || "").toString().trim();
  if (spec) t.idx.push(spec);
}

// --- Views ------------------------------------------------------------------
const views = [];
for (let i = 0; i < lines.length; i++) {
  const m = lines[i].match(/^\s*create\s+view\s+public\.([a-zA-Z0-9_]+)\s+as/i);
  if (m) views.push(m[1]);
}

// --- Policies ---------------------------------------------------------------
const policies = []; // {table,name,cmd,role}
for (let i = 0; i < lines.length; i++) {
  const m = lines[i].match(/^\s*create\s+policy\s+"?([^"]+)"?\s+on\s+public\.([a-zA-Z0-9_]+)\s+.*\s+for\s+(select|insert|update|delete|all)\s+to\s+([a-zA-Z0-9_ ,]+)\s+using/i);
  if (m) policies.push({ name: m[1], table: m[2], cmd: m[3], role: m[4] });
}

// --- Functions --------------------------------------------------------------
const fns = [];
for (let i = 0; i < lines.length; i++) {
  const m = lines[i].match(/^\s*create\s+or\s+replace\s+function\s+public\.([a-zA-Z0-9_]+)\s*\(/i);
  if (m) fns.push(m[1]);
}

// --- Render -----------------------------------------------------------------
let md = "";
md += "# Data Model â€” Snapshot (public schema)\n\n";
md += "> **Source of truth:** `db/SCHEMA.sql`. This file is auto-generated by `scripts/data-model-from-sql.mjs`.\n\n";
md += "## Tables\n";

for (const t of tables) {
  md += `\n### ${t.name}\n`;
  for (const c of t.cols) {
    const nn = c.nullable ? "" : ", **not null**";
    const def = c.def ? `, default: \`${c.def}\`` : "";
    md += `- **${c.name}** (${c.type}${nn}${def})\n`;
  }
  if (t.uniques.length) {
    md += `\n**Constraints**\n`;
    for (const u of t.uniques) md += `- ${u}\n`;
  }
  if (t.idx.length) {
    md += `\n**Indexes**\n`;
    for (const s of t.idx) md += `- ${s}\n`;
  }
}

if (views.length) {
  md += `\n## Views\n`;
  for (const v of views) md += `- ${v}\n`;
}

if (policies.length) {
  md += `\n## Row-Level Security (summary)\n`;
  const byT = new Map();
  for (const p of policies) {
    if (!byT.has(p.table)) byT.set(p.table, []);
    byT.get(p.table).push(p);
  }
  for (const [table, ps] of byT) {
    md += `\n**${table}**\n`;
    for (const p of ps) md += `- "${p.name}": \`${p.cmd}\` to \`${p.role}\`\n`;
  }
}

if (fns.length) {
  md += `\n## Functions (public)\n`;
  for (const f of fns) md += `- ${f}\n`;
}

md += `\n---\n_Last generated: ${new Date().toISOString()}_\n`;

writeFileSync(outPath, md, "utf8");
console.log(`Wrote ${outPath}`);
