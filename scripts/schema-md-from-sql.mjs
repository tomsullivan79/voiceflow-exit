// scripts/schema-md-from-sql.mjs
import { readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";

const SQL = readFileSync(join(process.cwd(), "db/SCHEMA.sql"), "utf8");
const outPath = join(process.cwd(), "db/SCHEMA.md");

// --- very small parser (tables + columns + indexes + notes) -----------------
const lines = SQL.replace(/\r\n/g, "\n").split("\n");

// capture CREATE TABLE blocks
const tables = []; // { name, columns:[{name,type,nullable,default}], constraints:[], comments:[] }
for (let i = 0; i < lines.length; i++) {
  const m = lines[i].match(/^\s*create\s+table\s+public\.([a-zA-Z0-9_]+)\s*\(\s*$/i);
  if (!m) continue;
  const name = m[1];
  const cols = [];
  const constraints = [];
  let j = i + 1;
  for (; j < lines.length; j++) {
    const line = lines[j].trim();
    if (/^\)\s*(tablespace|;)/i.test(line) || line === ");") { break; }
    if (!line) continue;
    // constraint lines
    if (/^constraint\s+/i.test(line)) {
      constraints.push(line.replace(/,\s*$/, ""));
      continue;
    }
    // column line: <name> <type> [not|null] [default ...]
    // remove trailing comma
    const raw = line.replace(/,\s*$/, "");
    const m2 = raw.match(/^"?(?<col>[a-zA-Z0-9_]+)"?\s+(?<type>[^,\s]+(?:\s+\([^)]+\))?(?:\s+with\s+time\s+zone)?)(?<rest>.*)$/i);
    if (!m2) continue;
    const col = m2.groups.col;
    const typ = m2.groups.type.replace(/\s+/g, " ").trim();
    const rest = m2.groups.rest || "";
    const nullable = !/\bnot null\b/i.test(rest);
    const defm = rest.match(/\bdefault\s+([^,]+)$/i);
    const defv = defm ? defm[1].trim() : null;
    cols.push({ name: col, type: typ, nullable, def: defv });
  }
  tables.push({ name, columns: cols, constraints });
  i = j;
}

// capture CREATE INDEX blocks and attach to tables
const idxMap = new Map(); // name -> [index strings]
for (const t of tables) idxMap.set(t.name, []);
for (const line of lines) {
  const m = line.match(/^\s*create\s+index\s+.*\s+on\s+public\.([a-zA-Z0-9_]+)\s+using\s+([a-zA-Z0-9_]+)\s*\((.+)\)/i)
       || line.match(/^\s*create\s+unique\s+index\s+.*\s+on\s+public\.([a-zA-Z0-9_]+)\s*\((.+)\)/i)
       || line.match(/^\s*create\s+index\s+.*\s+on\s+public\.([a-zA-Z0-9_]+)\s*\((.+)\)/i);
  if (!m) continue;
  const table = m[1];
  const spec = m[3] ? `${m[2].toUpperCase()}(${m[3]})` : m[2] ? m[2].toUpperCase() : m[0];
  const human = m[3] ? `${m[3]}` : (m[2] || "").toUpperCase();
  if (!idxMap.has(table)) idxMap.set(table, []);
  idxMap.get(table).push(human.replace(/\s+/g, " ").trim());
}

// capture simple CREATE VIEW names
const views = [];
for (let i = 0; i < lines.length; i++) {
  const m = lines[i].match(/^\s*create\s+view\s+public\.([a-zA-Z0-9_]+)\s+as/i);
  if (m) views.push(m[1]);
}

// capture policies summary
const policies = []; // { table, name, cmd, role }
for (let i = 0; i < lines.length; i++) {
  const m = lines[i].match(/^\s*create\s+policy\s+"?([^"]+)"?\s+on\s+public\.([a-zA-Z0-9_]+)\s+.*\s+for\s+(select|insert|update|delete|all)\s+to\s+([a-zA-Z0-9_ ,]+)\s+using/i);
  if (m) policies.push({ name: m[1], table: m[2], cmd: m[3], role: m[4] });
}

// capture functions (names only)
const fn = [];
for (let i = 0; i < lines.length; i++) {
  const m = lines[i].match(/^\s*create\s+or\s+replace\s+function\s+public\.([a-zA-Z0-9_]+)\s*\(/i);
  if (m) fn.push(m[1]);
}

// generate Markdown
function mdEsc(s) { return s.replace(/_/g, "\\_"); }

let md = "";
md += "# DB Schema â€” Human Snapshot (public)\n\n";
md += "> Source of truth is `db/SCHEMA.sql`. This file is generated by `scripts/schema-md-from-sql.mjs`.\n\n";

md += "## Tables\n";
for (const t of tables) {
  md += `\n### ${t.name}\n`;
  for (const c of t.columns) {
    const d = c.def ? `, default: \`${c.def}\`` : "";
    const nn = c.nullable ? "" : ", **not null**";
    md += `- **${c.name}** (${c.type}${nn}${d})\n`;
  }
  // constraints (only surface uniques quickly)
  const uniques = t.constraints.filter(s => /unique/i.test(s));
  if (uniques.length) {
    md += `\n**Constraints**\n`;
    for (const u of uniques) md += `- ${u}\n`;
  }
  const idx = idxMap.get(t.name) || [];
  if (idx.length) {
    md += `\n**Indexes**\n`;
    for (const i of idx) md += `- ${i}\n`;
  }
}

if (views.length) {
  md += `\n## Views\n`;
  for (const v of views) md += `- ${v}\n`;
}

if (policies.length) {
  md += `\n## Row-Level Security (summary)\n`;
  const byTable = new Map();
  for (const p of policies) {
    if (!byTable.has(p.table)) byTable.set(p.table, []);
    byTable.get(p.table).push(p);
  }
  for (const [table, list] of byTable) {
    md += `\n**${table}**\n`;
    for (const p of list) {
      md += `- "${p.name}": \`${p.cmd}\` to \`${p.role}\`\n`;
    }
  }
}

if (fn.length) {
  md += `\n## Functions (public)\n`;
  for (const f of fn) md += `- ${f}\n`;
}

md += `\n---\n_Last generated: ${new Date().toISOString()}_\n`;

writeFileSync(outPath, md, "utf8");
console.log(`Wrote ${outPath}`);
